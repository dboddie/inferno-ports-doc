# Floating point instructions

Microcontrollers based on Cortex-M4 cores typically provide floating point
units that support single precision floating point arithmetic operations
defined by the ARM FPv4-SP architecture, which is part of the ARMv7-M
architecture.
Since Inferno relies on double precision support, it is necessary to implement
software emulation of double precision arithmetic instructions.

References to sections of the ARMv7-M Architecture Reference Manual are
used to indicate which instructions are being discussed.

## Instruction set

Some floating point instructions that the compiler uses appear to be supported
by the FPUs provided by some Cortex-M4 cores.

====================    =================   ============
ARM instruction         Compiler mnemonic   Reference
--------------------    -----------------   ------------
VMOV Rt,Sn              MOVDW               A7.7.240
VMOV Sn,Rt              MOVWD               A7.7.240
VSTR Sd,[Rn,offset]     MOVD                A7.7.256 T2
VLDR Sd,[Rn,offset]     MOVD                A7.7.233 T2
====================    =================   ============

These are data transfer operations between floating point registers and either
normal registers or memory addressed using normal registers.

## Undefined instructions

These instructions are needed by Inferno and are generated by the compiler.

====================    =================   ============
ARM instruction         Compiler mnemonic   Reference
--------------------    -----------------   ------------
VMOV Dd,immediate       MOVD                A7.7.236
VCVT Dd,Sm<br>          CVT                 A7.7.225
VCVT Sd,Dm              CVT                 A7.7.225
VCMP Dd,Dm              CMPD                A7.7.223
VMOV Dd,Dm              MOVD                A7.7.237
VDIV Dd,Dn,Dm           DIVD                A7.7.229
VADD Dd,Dn,Dm           ADDD                A7.7.222
VSUB Dd,Dn,Dm           SUBD                A7.7.257
VMUL Dd,Dn,Dm           MULD                A7.7.245
====================    =================   ============

Because they are not supported by the FPU, they need to be trapped and emulated
in software. More complicated mathematical operations are handled by other
support code.

## Setting up floating point support

Typically, a Cortex-M processor with an FPU does not enable it by default.
It is up to Inferno to enable it and handle any undefined instructions that are
encountered.

Floating point support is provided by two coprocessors: CP10 and CP11. These
are enabled by setting the appropriate bits in the coprocessor access register
(CPACR) in the System Control Block (SCB). This initialisation is done in the
`trapinit` function that is called during the boot sequence.

To ensure that handling of undefined instructions can be performed by the
UsageFault handler instead of the HardFault handler, the UsageFault exception
needs to be enabled, and this is also done in the `trapinit` function.

## Handling the undefined instruction exception

When the processor encounters an undefined instruction, an exception occurs,
causing the processor to jump to the appropriate handler using the address
supplied in the vector table. Since the UsageFault exception is enabled in
`trapinit`, the corresponding handler is used to handle undefined instructions.
This can be found in the `l.s` file for each port.

We will start by referring to the
[Apollo3](https://github.com/dboddie/inferno-os/blob/apollo3/os/apollo3/l.s)
implementation to describe the mechanism.

When the exception occurs, the `_usage_fault` handler is called. The processor
saves registers R0-R3, R12, R14, PC and xPSR on the stack, as well as a
complete set of floating point registers. R0 is stored at the address pointed
to by the stack pointer, and the other register are stacked in ascending
order above it.

The handler begins by recording the value that the stack pointer would have had
before the exception occurred:

```
TEXT _usage_fault(SB), THUMB, $-4

    MOVW    SP, R1      /* Record the interrupted stack pointer. */
    ADD     $0x68, R1   /* Includes FP registers. */
```

This is for diagnostic purposes, in case an exception occurs that is not
handled by the floating point code. In order to preserve the state of the
interrupted code, all other registers that are not already stacked are pushed
onto the stack, including the link register holding the return address:

```
    PUSH(0x0ffa, 1)
    MOVW    SP, R0
    BL ,usage_fault(SB)
    POP(0x0ffa, 1)
```

The handler can then call the `usage_fault` function in
[trap.c](https://github.com/dboddie/inferno-os/blob/cortexm/os/cortexm/trap.c)
with the current stack pointer as an argument. If the necessary handling occurs
successfully, the function will return and all the registers can be restored
along with the return address, which is placed directly into the program
counter by the POP instruction.

Looking at the `usage_fault` function, we see that the argument passed to it
is used to refer to the stacked register values via the `Ereg` structure.
If the UsageFault Status Register (UFSR) indicates that an undefined
instruction exception occurred, the `fpithumb2` function is called with the
same argument to allow the floating point emulator to access and manipulate
the stacked values:

```
void usage_fault(Ereg *er)
{
    /* Entered with sp pointing to an Ereg struct. */

    if ((*(short *)UFSR_ADDR) & UFSR_UNDEFINSTR) {
        if (fpithumb2(er)) {
            *(short *)UFSR_ADDR |= UFSR_UNDEFINSTR;
            return;
        }
    }
```

If all went well, the instruction was handled and the exception is cleared in
the UFSR. Otherwise, the exception is reported and an infinite loop is
executed:

```
    wrstr("Usage fault at "); wrhex((int)er->pc); newline();
    wrstr("UFSR="); wrhex(*(short *)UFSR_ADDR); newline();
    wrstr("CFSR="); wrhex(*(int *)CFSR_ADDR); newline();
    wrstr("SHCSR="); wrhex(*(int *)SHCSR_ADDR); newline();
    wrstr("FPCCR="); wrhex(*(int *)FPCCR_ADDR); newline();
    wrstr("up="); wrhex((int)up); newline();

    dumperegs(er);

    for (;;) {}
}
```

Another way to handle the failure case would be to call `panic` and restart the
system.

## Emulating instructions

The `fpithumb2` function is implemented in the
[fpithumb2.c](https://github.com/dboddie/inferno-os/blob/cortexm/os/cortexm/trap.c)
file. This decodes undefined instructions to determine which operations need
to be performed and which registers (normal and floating point) are used.
Some operations, such as copying values between registers, are implemented
directly in the `fpithumb2` function. Others that involve arithmetic or
conversion between formats are performed by another set of functions.

The function begins by accessing the `Ereg` structure to read the contents of
memory where the undefined instruction occurred, reading the instruction in
two 16-bit parts:

```
int
fpithumb2(Ereg *er)
{
    ushort w0 = *(ushort *)er->pc;
    ushort w1 = *(ushort *)(er->pc + 2);
```

A number of variables are declared to keep track of the various register
numbers and immediate values. These include some `Internal` structures that
are used to hold floating point values in a more appropriate format for the
support functions to manipulate:

```
    ulong imm, ea;
    ulong Fd, Fm, Fn;   // just register numbers, either R, S or D
    ulong Rt, Rn;
    Internal in1, in2, inr;
```

The two halves of the instruction are checked against recognised bit patterns
in a switch statement. Each group of instructions with a common bit patterns
are grouped together under the same case statement.

The first group of instructions begins like this:

```
    switch (w0 & 0xffb0) {
    case 0xeeb0:
    {
        if ((w1 & 0x40) == 0) {
            // MOVD (A7.7.236)
            Fd = (w1 >> 12) << 1;
            imm = ((w0 & 0xf) << 4) | (w1 & 0xf);
            // Expand the constant into the high register.
            er->s[Fd + 1] = VFPExpandImm64(imm);
            er->s[Fd] = 0;
```

The first branch in a series of if statements checks for a VMOV instruction
that the compiler refers to internally as MOVD, putting an immediate constant
value into a double precision floating point register represented by two single
precision registers. The pair of registers used and the encoded constant value
are extracted from the instruction, the constant is decoded to a suitable value
for the registers, then the value is written indirectly to the floating point
registers via locations on the stack.

Having processed the instruction, the program counter is updated and success
is reported to the usage fault handler:

```
        }
        er->pc += 4;
        return 1;
    }
```

When the interrupted code resumes, the updated values on the stack will be
written back to the floating point registers automatically by the exception
return mechanism.

Instructions like VADD and VSUB require more processing. These have different
bit patterns and appear in a later case statement:

```
    // ADDD (A7.7.222), SUBD (A7.7.257)
    case 0xee30:
    {
        Fd = (w1 >> 12) << 1;
        Fm = (w1 & 0x0f) << 1;
        Fn = (w0 & 0x0f) << 1;
```

The instruction contains information about the floating point registers that
the instruction operates on. The register numbers are decoded and used to
access the stack locations that correspond to the stacked registers:

```
        fpid2i(&in1, &er->s[Fn]);
        fpid2i(&in2, &er->s[Fm]);
```

Both values need to be converted the internal format for arithmetic to be
performed, and the `fpid2i` function is used to do this for the `in1` and
`in2` operands.

The type of operation is read from the instruction and the appropriate function
is called to perform an addition or subtraction:

```
        if (w1 & 0x40) {
            fsub(in2, in1, &inr);
        } else {
            fadd(in2, in1, &inr);
        }
```

Once a result has been obtained in the `inr` structure, it is converted back
to a suitable format and written directly to the location on the stack that
corresponds to the destination floating point register:

```
        fpii2d(&er->s[Fd], &inr);
        er->pc += 4;
        return 1;
    }
```

As before, the program counter is updated and success is reported to the
usage fault handler.

The other undefined instructions that are supported are handled in generally
the same way:

* Groups of instructions are matched against bit patterns, then individual
  instructions are selected by further comparisons.
* Operands are decoded: these are either floating point register numbers or
  immediate constants.
* Values are read from the locations of stacked floating point registers,
* Conversions between machine and internal formats are performed.
* Software routines are used to perform the appropriate operations.
* Flags in the floating point status and control register (FPSCR) are updated
  via the stacked value.

If the function fails to find a matching operation, it returns zero, leading to
the failure case described above.

## Compiler support

The `tl` linker/loader is responsible for generating Thumb-2 instructions,
including those floating point operations. These are generated in the
[utils/tl/thumb.c](https://github.com/dboddie/inferno-os/blob/cortexm/utils/tl/thumb.c)
file, with the `thumboptab` array containing the `Optab` structures describing
the characteristics of the instructions, and various functions performing the
instruction encoding.

The `thumbasmout` function is where instructions are selected and encoded via
helper functions for different types of instructions, including `thumbofsr` and
especially `thumbopfp`, which encodes most of the floating point instructions.
